package main

import (
	"reflect"
	"regexp"
	"strconv"
	"strings"
	"text/template"

	"github.com/actgardner/gogen-avro/schema"
)

type templateParams struct {
	NS  *schema.Namespace
	Pkg string
}

var templateFuncs = template.FuncMap{
	"typeof":                 typeof,
	"isExportedGoIdentifier": isExportedGoIdentifier,
	"indent":                 indent,
	"recordInfoLiteral":      recordInfoLiteral,
	"doc":                    doc,
	"goType":                 goType,
}

var genTemplate = template.Must(
	template.New("").
		Delims("«", "»").
		Funcs(templateFuncs).
		Parse(`
// Code generated by avrogen. DO NOT EDIT.

package «.Pkg»

import "github.com/rogpeppe/avro/avrotypegen"

«range $defName, $def  :=.NS.Definitions»
	«- if ne $defName .AvroName »
		// Alias «$defName» = «.AvroName»
	«- else if eq (typeof .) "RecordDefinition"»
		«- doc "// " .»
		type «.Name» struct {
		«- range $i, $_ := .Fields»
			«- doc "\t// " .»
			«- $type := goType .Type»
			«- if isExportedGoIdentifier .Name»
				«- .GoName» «$type.GoType»
			«- else»
				«- .GoName» «$type.GoType» ` + "`" + `json:«printf "%q" .Name»` + "`" + `
			«- end»
		«end»
		}

		// AvroRecord implements the avro.AvroRecord interface.
		func («.Name») AvroRecord() avrotypegen.RecordInfo {
			return «recordInfoLiteral .»
		}

		// TODO implement MarshalBinary and UnmarshalBinary methods?
	«else if eq (typeof .) "EnumDefinition"»
		«- doc "// " . -»
		type «.Name» int
		const (
		«- range $i, $sym := .Symbols»
		«$def.SymbolName $sym»«if eq $i 0» «$def.Name» = iota«end»
		«- end»
		)
		// TODO UnmarshalText and String methods.
	«else if eq (typeof .) "FixedDefinition"»
		«- doc "// " . -»
		type «.Name» [«.SizeBytes»]byte
	«else»
		// unknown definition type «printf "%T; name %q" . (typeof .)» .
	«end»
«end»
`[1:]))

func quote(s string) string {
	if !strings.Contains(s, "`") {
		return "`" + s + "`"
	}
	return strconv.Quote(s)
}

type documented interface {
	Doc() string
}

func doc(indentStr string, d interface{}) string {
	if d, ok := d.(documented); ok && d.Doc() != "" {
		return "\n" + indent(d.Doc(), indentStr) + "\n"
	}
	return ""
}

func indent(s, with string) string {
	s = strings.TrimSuffix(s, "\n")
	if s == "" {
		return ""
	}
	return with + strings.Replace(s, "\n", "\n"+with, -1)
}

var goIdentifierPat = regexp.MustCompile(`^[A-Z][a-zA-Z_0-9]*$`)

func isExportedGoIdentifier(s string) bool {
	return goIdentifierPat.MatchString(s)
}
func typeof(x interface{}) string {
	if x == nil {
		return "nil"
	}
	t := reflect.TypeOf(x)
	if t.Kind() == reflect.Ptr {
		t = t.Elem()
	}
	if name := t.Name(); name != "" {
		return name
	}
	return ""
}
