// +build ignore

package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"text/template"
)

var testCodeTemplate = template.Must(
	template.New("").
		Delims("«", "»").
		Funcs(template.FuncMap{
			"quote":   quote,
			"mapKeys": mapKeys,
		}).
		Parse(`
// Code generated by generatetestcode.go; DO NOT EDIT.

package «.TestName»

import (
	"testing"

	"github.com/heetch/avro/avro-generate-go/internal/testutil"
)

var tests = testutil.RoundTripTest{
	InSchema: «quote .InSchema»,
	GoType: new(«.GoType»),
	Subtests: []testutil.RoundTripSubtest{
		«- range $k := mapKeys .Subtests»
		«- $t := index $.Subtests $k»{
			TestName: «printf "%q" $t.TestName»,
			InDataJSON: «quote $t.InData»,
			OutDataJSON: «quote $t.OutData»,
			«with $t.ExpectError -»
			ExpectError: map[testutil.ErrorType]string{
			«- range $k, $v := .»«quote $k»: «quote $v»,«end»},
			«end»
		}, «end»},
}

«if .GoTypeBody -»
type «.GoType» «.GoTypeBody»
«end»

func TestGeneratedCode(t *testing.T) {
	tests.Test(t)
}
`[1:]))

const generateDir = "internal/generated_tests"

type testData struct {
	TestName      string                 `json:"testName"`
	InSchema      json.RawMessage        `json:"inSchema"`
	OutSchema     json.RawMessage        `json:"outSchema"`
	GoType        string                 `json:"goType"`
	GoTypeBody    string                 `json:"goTypeBody"`
	GenerateError string                 `json:"generateError"`
	Subtests      map[string]subtestData `json:"subtests"`
}

type subtestData struct {
	TestName    string            `json:"testName"`
	InData      json.RawMessage   `json:"inData"`
	OutData     json.RawMessage   `json:"outData"`
	ExpectError map[string]string `json:"expectError"`
}

func mapKeys(m map[string]subtestData) (ks []string) {
	for k := range m {
		ks = append(ks, k)
	}
	sort.Strings(ks)
	return ks
}

func main() {
	var exported struct {
		Tests map[string]testData `json:"tests"`
	}
	var buf bytes.Buffer
	cmd := exec.Command("cue", "export")
	cmd.Dir = "./testdata"
	cmd.Stderr = os.Stderr
	cmd.Stdout = &buf
	err := cmd.Run()
	check("run cue export", err)
	err = json.Unmarshal(buf.Bytes(), &exported)
	if err != nil {
		log.Fatalf("cannot unmarshal test data: %v\n%s", err, &buf)
	}
	check("unmarshal test data", err)
	os.RemoveAll(generateDir)
	failed := false
	for _, test := range exported.Tests {
		dir := filepath.Join(generateDir, test.TestName)
		err := os.MkdirAll(dir, 0777)
		check("mkdir", err)
		if test.OutSchema != nil {
			file := filepath.Join(dir, "schema.avsc")
			err = ioutil.WriteFile(file, []byte(test.OutSchema), 0666)
			check("create schema file", err)

			var buf bytes.Buffer
			cmd := exec.Command("avro-generate-go", "-p", test.TestName, "schema.avsc")
			cmd.Stderr = &buf
			cmd.Stdout = &buf
			cmd.Dir = dir
			err = cmd.Run()
			if test.GenerateError != "" {
				if err == nil {
					fmt.Fprintf(os.Stderr, "avro-generate-go unexpectedly succeeded in test %s (%s)\n", test.TestName, dir)
					failed = true
					continue
				} else {
					pat, err := regexp.Compile("^(" + test.GenerateError + "$")
					check("generateError regexp", err)
					if !pat.MatchString(buf.String()) {
						fmt.Fprintf(os.Stderr, "avro-generate-go failed with unexpected error;\ngot %q\nwant %s\n", buf, test.GenerateError)
						failed = true
						continue
					}
				}
				// If there's an expected generation error, we don't want the
				// test directory any more.
				err := os.RemoveAll(dir)
				check("remove dir", err)
				continue
			}
			check("avro-generate-go "+file, err)
		} else {
			// The Go tool seems to require at least some
			// non-test code, at least when run with coverage engaged.
			err = ioutil.WriteFile(filepath.Join(dir, "dummy.go"), []byte("package "+test.TestName+"\n"), 0666)
			check("write dummy", err)
		}
		var buf bytes.Buffer
		err = testCodeTemplate.Execute(&buf, test)
		check("generate test code", err)
		goSource, fmtErr := format.Source(buf.Bytes())
		if fmtErr != nil {
			goSource = buf.Bytes()
		}
		outFile := filepath.Join(dir, "roundtrip_test.go")
		err = ioutil.WriteFile(outFile, goSource, 0666)
		check("write test go file", err)
		if fmtErr != nil {
			check("gofmt test code "+outFile, fmtErr)
		}
	}
	if failed {
		os.Exit(1)
	}
}

func check(what string, err error) {
	if err != nil {
		fmt.Fprintf(os.Stderr, "generatetestcode: %s: %v\n", what, err)
		os.Exit(1)
	}
}

func quote(b interface{}) string {
	var s string
	switch b := b.(type) {
	case []byte:
		s = string(b)
	case json.RawMessage:
		s = string(b)
	case string:
		s = b
	default:
		panic(fmt.Errorf("cannot quote %T", b))
	}
	if !strings.Contains(s, "`") {
		return "`" + s + "`"
	}
	return strconv.Quote(s)
}
