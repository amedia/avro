package avro

import (
	"bytes"
	"fmt"
	"io"
	"log"
	"reflect"

	"github.com/actgardner/gogen-avro/compiler"
	"github.com/actgardner/gogen-avro/vm"
)

// Unmarshal unmarshals the given Avro-encoded binary
// data, written with the given schema, into v, which should
// be a pointer to a struct type generated by avro-generate-go.
// TODO provide a way of unmarshaling single-object-encoded
// data along with a way of retrieving external schemas.
func Unmarshal(data []byte, x interface{}, writerSchema string) error {
	var readerSchema string
	if x, ok := x.(AvroRecord); ok {
		readerSchema = x.AvroRecord().Schema
	} else {
		// TODO generate schema from type
		return fmt.Errorf("cannot get schema info for %T", x)
	}
	prog, err := compiler.CompileSchemaBytes([]byte(writerSchema), []byte(readerSchema))
	if err != nil {
		return fmt.Errorf("cannot compile schemas: %v", err)
	}
	v := reflect.ValueOf(x)
	if v.Kind() != reflect.Ptr {
		return fmt.Errorf("not pointer destination %T", x)
	}
	return unmarshal(bytes.NewReader(data), prog, v.Elem())
}

type stackFrame struct {
	Boolean   bool
	Int       int64
	Float     float64
	Bytes     []byte
	String    string
	Condition bool
}

type decoder struct {
	pc      int
	program *program

	buf     []byte
	scan    int
	r       io.Reader
	readErr error
}

type decodeError struct {
	err error
}

// unmarshal unmarshals Avro binary data from r and writes it to target
// following the given program.
func unmarshal(r io.Reader, program *vm.Program, target reflect.Value) (err error) {
	defer func() {
		switch panicErr := recover().(type) {
		case *decodeError:
			err = panicErr.err
		case nil:
		default:
			panic(panicErr)
		}
	}()
	// TODO do this only once for any given type and cache
	// the result.
	prog, err := analyzeProgramTypes(program, target.Type())
	if err != nil {
		return fmt.Errorf("analysis failed: %v", err)
	}
	d := decoder{
		r:       r,
		buf:     make([]byte, 0, bufSize),
		program: prog,
	}
	d.eval(target)
	return nil
}

func (d *decoder) eval(target reflect.Value) {
	if target.IsValid() {
		log.Printf("eval %s", target.Type())
	} else {
		log.Printf("eval nil")
	}
	defer log.Printf("}")
	var frame stackFrame
	for ; d.pc < len(d.program.Instructions); d.pc++ {
		log.Printf("x %d: %v", d.pc, d.program.Instructions[d.pc])
		switch inst := d.program.Instructions[d.pc]; inst.Op {
		case vm.Read:
			switch inst.Operand {
			case vm.Null:
			case vm.Boolean:
				frame.Boolean = d.readBool()
			case vm.Int:
				// TODO bounds check
				frame.Int = d.readLong()
			case vm.Long:
				frame.Int = d.readLong()
			case vm.UnusedLong:
				d.readLong()
			case vm.Float:
				frame.Float = d.readFloat()
			case vm.Double:
				frame.Float = d.readDouble()
			case vm.Bytes:
				frame.Bytes = d.readBytes()
			case vm.String:
				frame.String = d.readString()
			default:
				frame.Bytes = d.readFixed(inst.Operand - 11)
			}
		case vm.Set:
			log.Printf("%v on %s", inst, target.Type())
			switch inst.Operand {
			case vm.Null:
			case vm.Boolean:
				target.SetBool(frame.Boolean)
			case vm.Int, vm.Long:
				// This is called on union types to set
				// the kind of union. TODO remove this hack!
				func() {
					defer func() {
						recover()
					}()
					target.SetInt(int64(frame.Int))
				}()
			case vm.Float, vm.Double:
				target.SetFloat(float64(frame.Float))
			case vm.Bytes:
				if target.Kind() == reflect.Array {
					n := reflect.Copy(target, reflect.ValueOf(frame.Bytes))
					if n != len(frame.Bytes) {
						d.error(fmt.Errorf("copied too little"))
					}
				} else {
					data := make([]byte, len(frame.Bytes))
					copy(data, frame.Bytes)
					target.SetBytes(data)
				}
			case vm.String:
				target.SetString(frame.String)
			}
		case vm.SetDefault:
			if d.program.makeDefault[d.pc] == nil {
				panic(fmt.Errorf("no makeDefault at PC %d; prog %p", d.pc, &d.program.makeDefault[0]))
			}
			target.Field(inst.Operand).Set(reflect.ValueOf(d.program.makeDefault[d.pc]()))
		case vm.Enter:
			val, isRef := d.program.enter[d.pc](target)
			log.Printf("enter %d -> %#v (isRef %v) {", inst.Operand, val, isRef)
			d.pc++
			d.eval(val)
			if !isRef {
				target.Set(val)
			}
		case vm.Exit:
			log.Printf("}")
			return
		case vm.AppendArray:
			target.Set(reflect.Append(target, reflect.Zero(target.Type().Elem())))
			d.pc++
			d.eval(target.Index(target.Len() - 1))
		case vm.AppendMap:
			d.pc++
			elem := reflect.New(target.Type().Elem()).Elem()
			d.eval(elem)
			if target.IsNil() {
				// TODO we'd like to encode (null | map) by using a nil
				// map value, but because we're only making the map
				// when we append the first element, all empty maps
				// will also be nil. Perhaps when SetLong is called on the
				// union type, we should create the map.
				target.Set(reflect.MakeMap(target.Type()))
			}
			target.SetMapIndex(reflect.ValueOf(frame.String), elem)
		case vm.Call:
			curr := d.pc
			d.pc = inst.Operand
			d.eval(target)
			d.pc = curr
		case vm.Return:
			return
		case vm.Jump:
			d.pc = inst.Operand - 1
		case vm.EvalGreater:
			frame.Condition = frame.Int > int64(inst.Operand)
		case vm.EvalEqual:
			frame.Condition = frame.Int == int64(inst.Operand)
		case vm.CondJump:
			if frame.Condition {
				d.pc = inst.Operand - 1
			}
		case vm.AddLong:
			frame.Int += int64(inst.Operand)
		case vm.SetLong:
			frame.Int = int64(inst.Operand)
		case vm.MultLong:
			frame.Int *= int64(inst.Operand)
		case vm.PushLoop:
			loop := frame.Int
			d.pc++
			d.eval(target)
			frame.Int = loop
		case vm.PopLoop:
			return
		case vm.Halt:
			if inst.Operand == 0 {
				// TODO this doesn't actually halt.
				return
			}
			d.error(fmt.Errorf("Runtime error: %v, frame: %v, pc: %v", d.program.Errors[inst.Operand-1], frame, d.pc))
		default:
			d.error(fmt.Errorf("Unknown instruction %v", d.program.Instructions[d.pc]))
		}
	}
}

func (d *decoder) check(err error, what string) {
	if err != nil {
		d.error(fmt.Errorf("%s: %v", what, err))
	}
}

func (d *decoder) error(err error) {
	panic(&decodeError{
		err: err,
	})
}
